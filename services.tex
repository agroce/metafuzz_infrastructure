%\clg{from the call: ``describe services to be integrated into the infrastructure, including 
%mechanisms by which researchers will gain access to the infrastructure;''}
%\clg{I'm wondering if one of the subsections I initially grouped under 
%tools/resources/datasets might fit better down here.}

% User Services

A good first impression will be key in engendering trust in our meta-fuzzing infrastructure.
Thus, we will provide ready-made images (Docker or VM) so that users can experience
the end-to-end system depicted in Figure~\ref{fig:overview}.
We will provide a suite of such images, pre-configured with various combination of
fuzzers (e.g., AFL++, LibAFL, libFuzzer), 
fuzzing styles (e.g., whole program, library-based, source, binary), 
and benchmarks (e.g, OSS Fuzz benchmarks, programs written in
different languages).

A key element of the infrastructure is that adding fuzzers and
benchmarks must be servicable. For example, users should be able define the
``ports'' the fuzzer accesses, in the vision of Figure~\ref{fig:meta},
e.g., where a fuzzer looks for new seeds when running in ensemble
mode, whether it takes an uninstrumented binary or requires binaries
to compiled, and so forth.  Given a simple DSL for this kind of
extension, adding a new fuzzer should potentialy require almost no
effort in many cases.  However, for fuzzers with complex build or
runtime workflows, e.g., ones requiring multiple binaries such as
Angora, users will be able to provide full scripts defining fuzzers,
as in FuzzBench.

We will actively develop and maintain user documentation, cookbooks and tutorials throughout
the duration of the project. We will support both users that want to just use the system
as well as those researchers that wish to extend the system.
In general, our tutorials and documentation of meta-fuzzing workflows will be
represented and concretized in ready-made images.

One service to the community our approach will offer is to reduce the
risk of performing improper evaluations of fuzzing research.  We aim
to clearly indicate community-expected standards for fuzzer
evaluations~\cite{FuzzerHicks}, document aspects of configuration that
are concerned, and set the defaults for our infrastructure to perform,
when not modified, high quality fuzzer evaluations.

We will host our software repository on GitHub and use standard GitHub facilities
to manage interactions with end users, e.g., issues, pull requests, discussions, feature requests.
Over time, other researchers and practitioners will extend the base infrastructure with
new fuzzers, benchmarks, transformations, heuristics to guide meta-fuzzing, etc. 
While we will initially serve as gatekeepers to decide when contributions from the community
should be folded into the mainline release, we will coordinate with our advisory board and active community 
members to articulate governance policies for the project.

Note that unlike OSS Fuzz, our primary aim is not to provide
fuzzing-as-a-service (which we will only do during the initial
exploratory phase, to help users understand the system and offer a
return for their input on needed features), but
rather, to provide the software necessary to enable easy-to-deploy and extend meta-fuzzing 
capabilities (though, of course, our software stack could be used to power such a service).

